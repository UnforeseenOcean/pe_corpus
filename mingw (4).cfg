[global]
#[TODO] Delete this section
#minir is not done. Some things in this config file exist, but do nothing; they are marked with [TODO].
# Each TODO tag applies to only the option directly after it, and the comments do accurately describe its planned function.
#The comments also often refer to a config panel that doesn't exist.
#More config options may appear in the future. Some of them, especially the ones marked TODO, may even disappear.
#
#As there is no config panel yet, a list of possible drivers follows:
#Video: Direct3D[W], OpenGL[W][L], XShm[L], GDI[W]
#Audio: PulseAudio[L], DirectSound[W]
#Input: RawInput[W], DirectInput[W], udev[L], GDK[L], XInput2[L], X11[L]
#[W] means available on Windows; [L] means available on Linux.
#They are in order of descending desirability; the first one is best, except that pure-Linux drivers are in no particular order relative to pure-Windows.
#Note that using udev requires access to various items in /dev/input, which requires either chmodding them or running minir with escalated privileges.

#It's fine to edit this file; in fact, you need to edit this file if you want core- or game-specific settings.
#If you do anything wrong, minir will remove the offending line from this file and stick in the default value.
#This means that if the line remains after being loaded and saved, minir understood it.
#Your other settings are safe if you damage a line, except if you damage a core or game path, or a section header.
#Most numbers are clamped within a reasonable interval; if you insert something unreasonable, minir will clamp it to the nearest limit.

#This one is whether to update this file once minir exits. Note that if writing is disabling, invalid directives won't be validated.
#Can't be set non-global.
readonly=false

#Verbosity is how much things are put in this file.
#3: Include everything.
#2: Like 3, but remove unchanged entries from the joypad mappings. This is the default.
#1: Like 2, but remove comments too.
#0: Like 1, but remove instructions to change any value to its default (not just large arrays). [TODO] Actually remove these entries if they're present.
#The config panel does not include this one, since it has no effect on the GUI.
#Can't be set non-global.
verbosity=2

#Not all drivers support synchronizing. Video/OpenGL on Windows with DWM enabled, for example, doesn't.
#Which drivers are supported is not listed here; it varies. Use the config panel.

driver_video=Direct3D
video_scale=2
video_sync=true
#This one increases framerate quite a bit, but makes it stutter under some circumstances.
#[TODO] (delete maybe?)
video_frameskip=false
#This one moves the video driver to its own thread, giving massive framerate boosts under some circumstances.
#It is also mandatory for screenshots to work. Only turn it off if you're experiencing bugs.
video_thread=true

driver_audio=DirectSound
audio_latency=120
audio_sync=true

#You can set these separately, but it's better to use the same driver for everything.
driver_inputkb=RawInput
#[TODO]
driver_inputmouse=
#[TODO]
driver_inputjoy=

#Whether to automatically look for cores in the most plausible places if told to open an unknown ROM.
#If this is false, you'll have to show minir the cores by yourself, or accept (or even want) minir to fail loading unfamiliar ROMs.
#Can't be set non-global.
auto_locate_cores=true

input_joy_p1_up=KB1::Up
input_joy_p1_dn=KB1::Down
input_joy_p1_lf=KB1::Left
input_joy_p1_rt=KB1::Right
input_joy_p1_aa=KB1::X
input_joy_p1_bb=KB1::Z
input_joy_p1_xx=KB1::S
input_joy_p1_yy=KB1::A
input_joy_p1_st=KB1::Return
input_joy_p1_se=KB1::Space
input_joy_p1_l1=KB1::Q
input_joy_p1_r1=KB1::W
input_joy_p1_l2=
input_joy_p1_r2=
input_joy_p1_l3=
input_joy_p1_r3=

#[TODO]
input_joy_auto_p1_up=
input_joy_auto_p1_dn=
input_joy_auto_p1_lf=
input_joy_auto_p1_rt=
input_joy_auto_p1_aa=
input_joy_auto_p1_bb=
input_joy_auto_p1_xx=
input_joy_auto_p1_yy=
input_joy_auto_p1_st=
input_joy_auto_p1_se=
input_joy_auto_p1_l1=
input_joy_auto_p1_r1=
input_joy_auto_p1_l2=
input_joy_auto_p1_r2=
input_joy_auto_p1_l3=
input_joy_auto_p1_r3=

#This one is whether to block left+right and up+down. If blocked, both are ignored while the other is held.
#(I'm open to suggestions for how else it could act.)
#Note that the libretro core may also block L+R. If it does, L+R will only go through if both minir and the core says it should.
joypad_block_opposing=true

input_savestate_load1=KB1::F1
input_savestate_load2=KB1::F2
input_savestate_load3=KB1::F3
input_savestate_load4=KB1::F4
input_savestate_load5=KB1::F5
input_savestate_load6=KB1::F6
input_savestate_load7=KB1::F7
input_savestate_load8=KB1::F8
input_savestate_load9=KB1::F9
input_savestate_load10=KB1::F10
input_savestate_save1=KB1::ShiftL+F1, KB1::ShiftR+F1
input_savestate_save2=KB1::ShiftL+F2, KB1::ShiftR+F2
input_savestate_save3=KB1::ShiftL+F3, KB1::ShiftR+F3
input_savestate_save4=KB1::ShiftL+F4, KB1::ShiftR+F4
input_savestate_save5=KB1::ShiftL+F5, KB1::ShiftR+F5
input_savestate_save6=KB1::ShiftL+F6, KB1::ShiftR+F6
input_savestate_save7=KB1::ShiftL+F7, KB1::ShiftR+F7
input_savestate_save8=KB1::ShiftL+F8, KB1::ShiftR+F8
input_savestate_save9=KB1::ShiftL+F9, KB1::ShiftR+F9
input_savestate_save10=KB1::ShiftL+F10, KB1::ShiftR+F10

#There are 100 savestate slots; the above mappings refer to the first ten slots.
input_savestate_slot_load=
input_savestate_slot_save=
input_savestate_slot_next=
input_savestate_slot_prev=
#These two move ten slots at the time.
input_savestate_slot_next_10=
input_savestate_slot_prev_10=

#[TODO]
input_savestate_manager=

#Shown in the savestate manager.
#See http://www.cplusplus.com/reference/ctime/strftime/ for documentation on the format.
#[TODO]
datefmt=%c

#Whether to automatically save a savestate when closing the ROM, and reload it when reloading the same ROM.
savestate_auto=false

#This one will disable savestates, as well as rewind (see below). Does not affect savestate_auto.
savestate_disable=false

#The screenshot name format is romname-yymmdd-hhmmss.png; not customizable. In case of overlaps, -## is appended before the extension.
input_screenshot=KB1::F12

#Turbo disables synchronizing audio and video. It does nothing unless either of the synchronization flags are enabled.
#Enabling normal turbo will disable toggle turbo once normal turbo is released.
input_turbo=KB1::Tab
input_turbo_toggle=

#This one pauses the game.
input_pause=
#Frame advance. Push it to move forward one frame. Works only while paused.
input_frame_adv=

#These two allow the framerate to move (very slowly) while paused; one frame takes the defined delay, in milliseconds.
input_frame_adv_hold=
input_frame_adv_hold_delay=500

#These allow you to multiply or divide the emulation speed by any integer.
#Note that it will still attempt to synchronize with the monitor, so if you set framerate higher than what
# the CPU can keep up with, the framerate will actually drop. Use fastforward if you encounter this.
input_slowdown=KB1::KP_Minus
input_speedup=KB1::KP_Plus

#minir's rewind system is Braid-like; hold a button and time flows backwards, -1x normal speed (where "normal" is
# defined as whatever input_slowdown and input_speedup say, multiplied by rewind_speedup).
rewind_enable=true
#The granularity is how many frames to wait between saving the states. 1 is the smoothest, but also the most CPU intensive.
#The framerate penalty should be around 10-15%[TODO: does this number still apply? it looks old], depending on the savestate size and how much CPU the core needs.
#Alternatively, if you prefer ZSNES style rewinds, you can set the granularity to something really high, and minir will go
# back to the previous rewind slot every time you press the button. The CPU penalty should, in this case, be neglible.
#("Really high" isn't defined; minir will go back to the previous slot on press even if the timer is low, and will go
# back another slot if you hold the button long enough. It's exactly the same system; only the usage patterns vary.)
rewind_granularity=1
#The turbo resolution allows you to increase the delay between rewind points while turbo is enabled, to decrease
# the framerate hit. 0 here will make it not save at all while turboing. Rewind speed is still 1x real time.
rewind_granularity_turbo=1
#This one makes rewinding go N times faster than realtime. It's independent of rewind_granularity,
# though you should probably set this lower than or equal to the granularity.
rewind_speedup=1
#This controls how much memory should be used by the rewind buffer, in megabytes.
#One rewind point usually takes about 0.5-2% of the size of a savestate on average, but it varies
# between cores, between games, and between parts of the game; for example, scene transitions and
# loading screens uses more. (But you shouldn't need to rewind to the previous level, anyways.)
#If the buffer is filled up, the oldest data is discarded.
rewind_mem=64
#This one makes minir print how much the rewind buffer contains, as well as a guess on how much will fit before it fills up, on the status bar.
#Note that if rewind_delay does not equal rewind_delay_turbo and fastforward has been used, the reported value does not
# reflect how much fits in the rewind buffer; instead, it reflects how much would fit there if you had not used fastforward.
#Also note that scene transitions and loading screens take more space in the rewind buffer than normal gameplay.
#Finally, note that it is not guaranteed accurate, nor fully stable. The guess may be wrong,
# in both directions, and the amount of data that fits may change without obvious provocation.
rewind_stats=false
#And finally, this one is what to press to trigger it.
input_rewind=KB1::Backspace

#Maximum amount of memory used by the cheat search, in megabytes.
#If more memory than this would be needed, searching for a relationship with the previous value will be disabled.
cheat_mem=128

#Whether to create an SRAM file upon unloading the ROM (closing minir counts as ROM unload),
# and when detecting that game has been saved in-game, respectively.
#Note that the in-game saving detection mechanism isn't perfect, and may trigger on loading a new level in some games.
#If this annoys you, turn it off and rely on sram_write_unload or input_sram_write_manual.
sram_write_unload=true
#[TODO]
sram_write_auto=false
#[TODO]
input_sram_write_manual=

#Whether to hide the cursor if it's above the minir window and not moving.
cursor_hide=true

#Whether to pause the game if minir loses focus. Focusing on the menues or other minir windows will still pause the game.
defocus_pause=true
